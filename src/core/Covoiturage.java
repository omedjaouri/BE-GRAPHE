package core;

import java.awt.Color;
import java.io.PrintStream;
import java.util.List;

import base.Readarg;

public class Covoiturage extends Algo{

	private int zoneOrigine;
	private int o1, o2, d;
	private int destination;
	

	public Covoiturage(Graphe gr, PrintStream fichierSortie, Readarg readarg) {
		super(gr, fichierSortie, readarg);

		this.zoneOrigine = gr.getZone () ;
		this.o1 = readarg.lireInt ("Starting Node for car: ") ;

		// Demander la zone et le sommet destination.
		this.o2 = readarg.lireInt ("Starting Node for pieton: ");
		
		this.d = readarg.lireInt ("Destination Node for Covoiturage: ");
		
	}


	//Draws the route generated by Dijkstra
	public void drawRouteC(List<Label> route, int vehicle){
		for(Label l : route){
			if(l.getParent() != null){
				float lat1 = l.getCurrent().getCoord().getLatitude();
				float lat2 = l.getParent().getCoord().getLatitude();
				float long1 = l.getCurrent().getCoord().getLongitude();
				float long2 = l.getParent().getCoord().getLongitude();
				this.graphe.dessin.setColor(Color.RED);
				this.graphe.dessin.drawPoint(long1, lat1, 10);
				if(vehicle == 1)
					this.graphe.dessin.setColor(Color.GREEN);
				else
					this.graphe.dessin.setColor(Color.BLACK);
				this.graphe.dessin.setWidth(2);
				this.graphe.dessin.drawLine(long1, lat1, long2, lat2);
			}
		}
	}
	
	@Override
	public void run() {
		double current_min = Double.MAX_VALUE;
		Coordinate coor = new Coordinate(0,0);
		Node min_node = new Node(coor, 0);
		//Create a graph for the first Dijkstra (O2 -> D)
		Dijkstra car = new Dijkstra(this.graphe.NodeList);
		car.computeRoutes(this.graphe.NodeList.get(o1), this.graphe.NodeList.get(d), 
							false, this.graphe.getVitMax(), true, 0);
		//Create a graph for the 2nd Dijkstra (O1 -> D)
		Dijkstra pieton = new Dijkstra(this.graphe.NodeList);
		pieton.computeRoutes(this.graphe.NodeList.get(o2), this.graphe.NodeList.get(d), 
							false, this.graphe.getVitMax(), true, 1);
		//For every Node, check the minimum cost to the Node (in distance) and calculate A* to the destination
		for(Node n: this.graphe.NodeList){
			//Calculate c1 and c2
			double c1 = car.label.get(n).getCost();
			double c2 = pieton.label.get(n).getCost();
			
			//Find c3 by calculating A* from Node n to destination
			Dijkstra toDest = new Dijkstra(this.graphe.NodeList);
			toDest.computeRoutes(n, this.graphe.NodeList.get(d), true, this.graphe.getVitMax(), true, 0);
			
			List<Label> routedist = toDest.reversePath(this.graphe.NodeList.get(d));
			
			double c3 = routedist.get(routedist.size() - 1).getCost();
			
			double minimize = c1 + c2 + 2*c3;
			
			if(minimize <= current_min){
				current_min = minimize;
				min_node = n;
			}
				
		}
		
		//Calculate final distances for Drawing the graph.
		Dijkstra final_c1 = new Dijkstra(this.graphe.NodeList);
		final_c1.computeRoutes(this.graphe.NodeList.get(o1), min_node, 
				true, this.graphe.getVitMax(), true, 0);
		List<Label> routec1 = final_c1.reversePath(min_node);
		double costC1 = routec1.get(routec1.size() - 1).getCost();
		
		
		Dijkstra final_c2 = new Dijkstra(this.graphe.NodeList);
		final_c2.computeRoutes(this.graphe.NodeList.get(o2), min_node, 
				true, this.graphe.getVitMax(), true, 1);
		List<Label> routec2 = final_c2.reversePath(min_node);
		double costC2 = routec2.get(routec2.size() - 1).getCost();
		
		Dijkstra final_c3 = new Dijkstra(this.graphe.NodeList);
		final_c3.computeRoutes(min_node, this.graphe.NodeList.get(d), 
				true, this.graphe.getVitMax(), true, 0);
		List<Label> routec3 = final_c3.reversePath(this.graphe.NodeList.get(d));
		double costC3 = routec3.get(routec3.size() - 1).getCost();
		
		drawRouteC(routec1, 0);
		drawRouteC(routec2, 1);
		drawRouteC(routec3, 0);
		
		System.out.println("Minimizing Total Distance");
		System.out.println("O2: "+ o2 + " O1: " + o1 + " D: " + d);
		System.out.println("Min_Node (Meeting point): " + min_node.getIdentifier());
		System.out.println("Distance between Car and Min_Node: " + costC1);
		System.out.println("Distance between Pieton and Min_Node: " + costC2);
		System.out.println("Distance between Min_Node and Destination: " + costC3);
		
		
	}
	
	
	
}
